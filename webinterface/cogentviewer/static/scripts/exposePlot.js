// Generated by CoffeeScript 1.6.3
require(["dojo/topic", "dojo/io/script", "dojo/store/Memory", "dojo/ready", "dojo/request", "dojo/dom", "dojo/dom-construct", "dgrid/Grid", "dgrid/OnDemandGrid", "dijit/form/Button"], function(topic, ioscript, Memory, Ready, Request, dom, domConstruct, Grid, OnDemandGrid, Button) {
  var data, fetchData, percentFormatter, plotExposure, testRender, typeStore, writeTable;
  topic.subscribe("navTree", function(arg1) {
    fetchData(arg1);
  });
  data = [
    {
      id: 0,
      name: "Temperature"
    }, {
      id: 2,
      name: "Humidity"
    }
  ];
  typeStore = new Memory({
    data: data
  });
  Ready(function(obj) {
    var cols, dropdown;
    dropdown = dijit.byId("sensorType");
    dropdown.set("store", typeStore);
    cols = [
      {
        field: "first",
        label: "First Name"
      }, {
        field: "last",
        label: "Last Name"
      }, {
        field: "age",
        label: "Age"
      }
    ];
    data = [
      {
        first: "Bob",
        last: "Baker",
        age: 40
      }, {
        first: "Dave",
        last: "Lister",
        age: 55
      }, {
        first: "Pat",
        last: "Sajak",
        age: 64
      }
    ];
  });
  fetchData = function(args) {
    var graphDiv, item, sensorTypes, _i, _len;
    args.graphType = "expose";
    sensorTypes = [];
    if (args.sensorType === "") {
      sensorTypes = [0, 2];
    } else {
      sensorTypes = [args.sensorType];
    }
    graphDiv = dom.byId("graphs");
    domConstruct.destroy("theGraph");
    domConstruct.empty("graphs");
    for (_i = 0, _len = sensorTypes.length; _i < _len; _i++) {
      item = sensorTypes[_i];
      console.log("Fetching Data for ", item);
      args.graphType = "expose";
      args.sensorType = item;
      ioscript.get({
        url: "jsonFetch",
        content: args,
        callbackParamName: "callback"
      }).then(function(data) {
        var divid, exportBtn, newDom, newSec, sep;
        console.log("--> Data Returned ", data);
        divid = "graph" + data.divid;
        newSec = domConstruct.create("section", {}, "graphs");
        newDom = domConstruct.create("div", {
          id: divid
        }, newSec);
        plotExposure(data, newDom.id);
        divid = "table" + data.divid;
        newDom = domConstruct.create("div", {
          id: divid,
          style: "height:200px"
        }, newSec);
        exportBtn = domConstruct.create("button", {
          innerHTML: "Export"
        }, newSec);
        writeTable(data, newDom, exportBtn);
        sep = domConstruct.create("hr", {}, newSec, "after");
        console.log("--> Plotted");
      });
    }
  };
  plotExposure = function(theData, domItem) {
    var chart, options;
    options = {
      chart: {
        renderTo: domItem,
        defaultSeriesType: "column"
      },
      title: {
        text: "EXPOSE CHART"
      },
      exporting: {
        width: 1024
      },
      xAxis: {
        categories: []
      },
      yAxis: {
        title: {
          text: "Percentage of Samples"
        }
      },
      plotOptions: {
        column: {
          stacking: "percent",
          dataLabels: {
            enabled: true,
            style: {
              color: '#000000',
              fontSize: '12px'
            },
            format: '{percentage:.2f}%'
          }
        }
      },
      tooltip: {
        pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y:.2f}</b>Hours ({point.percentage:.2f}%)<br/>',
        shared: true
      },
      series: []
    };
    options.xAxis.categories = theData.labels;
    options.series = theData.series;
    options.title.text = theData.title;
    chart = new Highcharts.Chart(options);
  };
  percentFormatter = function(thefloat) {
    if (typeof thefloat === "string") {
      return thefloat;
    }
    return "" + (thefloat.toFixed(2)) + " %";
  };
  testRender = function(object, value, node, options) {
    console.log("Render Cell");
    console.log("--> Object", object);
    console.log("--> Value", value);
    console.log("--> Node", node);
    return node;
  };
  writeTable = function(theData, domItem, exportBtn) {
    var colidx, cols, dataitem, datalist, idx, item, itm, outData, srs, theBtn, theStore, thecount, thedata, thelabels, theseries, thisgrid, thisvalue, total, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    console.log("Writing Table");
    console.log(theData);
    theseries = theData.series;
    thelabels = theData.labels;
    console.log("SERIES ", theseries);
    console.log("LABELS ", thelabels);
    console.log("Dom Item ", domItem);
    outData = {};
    cols = [
      {
        field: "room",
        label: "Room"
      }
    ];
    idx = 0;
    for (_i = 0, _len = theseries.length; _i < _len; _i++) {
      item = theseries[_i];
      cols.push({
        field: "series" + idx,
        label: item["name"],
        formatter: percentFormatter
      });
      idx += 1;
    }
    theData = [];
    for (idx = _j = 0, _len1 = thelabels.length; _j < _len1; idx = ++_j) {
      itm = thelabels[idx];
      dataitem = {
        room: itm
      };
      console.log("--> Processing Label ", itm, "  idx", idx);
      total = 0;
      datalist = [];
      for (_k = 0, _len2 = theseries.length; _k < _len2; _k++) {
        srs = theseries[_k];
        console.log("--> --> And Series:", srs);
        thedata = srs.data;
        console.log("--> --> And (Data):", thedata);
        thisvalue = thedata[idx];
        thecount = thisvalue;
        total += thisvalue;
        datalist.push(thecount);
      }
      console.log("--> Series Done");
      colidx = 0;
      for (_l = 0, _len3 = datalist.length; _l < _len3; _l++) {
        srs = datalist[_l];
        console.log("Srs ", srs);
        if (srs > 0) {
          dataitem["series" + colidx] = (srs / total) * 100.0;
        } else {
          dataitem["series" + colidx] = 0.00;
        }
        colidx += 1;
      }
      console.log("--> Data Item ", dataitem);
      theData.push(dataitem);
    }
    theStore = new Memory({
      data: theData,
      toCSV: function(options) {
        var alwaysQuote, csvContent, delimiter, encodedURI, header, newline, output, row, _len4, _len5, _len6, _m, _n, _o;
        console.log("SAVING");
        options = options || {};
        alwaysQuote = options.alwaysQuote;
        header = options.header;
        data = this.data;
        delimiter = ",";
        newline = "\n";
        output = "";
        console.log("Options Init");
        console.log(this);
        console.log(data);
        console.log(header);
        for (_m = 0, _len4 = header.length; _m < _len4; _m++) {
          item = header[_m];
          output += "" + item["label"] + delimiter + " ";
        }
        output += "" + newline;
        for (_n = 0, _len5 = data.length; _n < _len5; _n++) {
          row = data[_n];
          for (_o = 0, _len6 = header.length; _o < _len6; _o++) {
            item = header[_o];
            dataitem = row[item.field];
            output += "" + dataitem + delimiter + " ";
          }
          output += "" + newline;
        }
        console.log(output);
        csvContent = "data:text/csv;charset=utf-8,";
        csvContent += output;
        encodedURI = encodeURI(csvContent);
        window.open(encodedURI);
        return output;
      }
    });
    console.log("Store is ", theStore);
    console.log("Colums == ", cols);
    console.log("Data == ", theData);
    thisgrid = new OnDemandGrid({
      columns: cols,
      store: theStore
    }, domItem);
    theBtn = new Button({
      onClick: function() {
        return theStore.toCSV({
          header: cols
        });
      }
    }, exportBtn);
    console.log("--> Done");
  };
});
